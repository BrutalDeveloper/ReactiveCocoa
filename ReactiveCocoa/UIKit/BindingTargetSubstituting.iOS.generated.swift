// This is auto-generated by gyb.

import Foundation
import ReactiveSwift
import enum Result.NoError
import UIKit

extension UIActivityIndicatorView {

	// isAnimating: Bool

	public static func <~ <Signal: SignalProtocol>(
		target: UIActivityIndicatorView,
		source: Signal
	) -> Disposable? where Signal.Value == Bool, Signal.Error == NoError {
		return target.reactive.isAnimating <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UIActivityIndicatorView,
		source: Producer
	) -> Disposable where Producer.Value == Bool, Producer.Error == NoError {
		return target.reactive.isAnimating <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UIActivityIndicatorView,
		source: Property
	) -> Disposable where Property.Value == Bool {
		return target.reactive.isAnimating <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UIActivityIndicatorView,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == Bool {
		return target.reactive.isAnimating <~ source
	}
}
extension NSLayoutConstraint {

	// constant: CGFloat

	public static func <~ <Signal: SignalProtocol>(
		target: NSLayoutConstraint,
		source: Signal
	) -> Disposable? where Signal.Value == CGFloat, Signal.Error == NoError {
		return target.reactive.constant <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: NSLayoutConstraint,
		source: Producer
	) -> Disposable where Producer.Value == CGFloat, Producer.Error == NoError {
		return target.reactive.constant <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: NSLayoutConstraint,
		source: Property
	) -> Disposable where Property.Value == CGFloat {
		return target.reactive.constant <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: NSLayoutConstraint,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == CGFloat {
		return target.reactive.constant <~ source
	}
}
extension UISwitch {

	// isOn: Bool

	public static func <~ <Signal: SignalProtocol>(
		target: UISwitch,
		source: Signal
	) -> Disposable? where Signal.Value == Bool, Signal.Error == NoError {
		return target.reactive.isOn <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UISwitch,
		source: Producer
	) -> Disposable where Producer.Value == Bool, Producer.Error == NoError {
		return target.reactive.isOn <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UISwitch,
		source: Property
	) -> Disposable where Property.Value == Bool {
		return target.reactive.isOn <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UISwitch,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == Bool {
		return target.reactive.isOn <~ source
	}
}
extension UITextView {

	// text: String

	public static func <~ <Signal: SignalProtocol>(
		target: UITextView,
		source: Signal
	) -> Disposable? where Signal.Value == String, Signal.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UITextView,
		source: Producer
	) -> Disposable where Producer.Value == String, Producer.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UITextView,
		source: Property
	) -> Disposable where Property.Value == String {
		return target.reactive.text <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UITextView,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == String {
		return target.reactive.text <~ source
	}
}
extension UIDatePicker {

	// date: Date

	public static func <~ <Signal: SignalProtocol>(
		target: UIDatePicker,
		source: Signal
	) -> Disposable? where Signal.Value == Date, Signal.Error == NoError {
		return target.reactive.date <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UIDatePicker,
		source: Producer
	) -> Disposable where Producer.Value == Date, Producer.Error == NoError {
		return target.reactive.date <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UIDatePicker,
		source: Property
	) -> Disposable where Property.Value == Date {
		return target.reactive.date <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UIDatePicker,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == Date {
		return target.reactive.date <~ source
	}
}
extension UITextField {

	// text: String?

	public static func <~ <Signal: SignalProtocol>(
		target: UITextField,
		source: Signal
	) -> Disposable? where Signal.Value == String?, Signal.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UITextField,
		source: Producer
	) -> Disposable where Producer.Value == String?, Producer.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UITextField,
		source: Property
	) -> Disposable where Property.Value == String? {
		return target.reactive.text <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UITextField,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == String? {
		return target.reactive.text <~ source
	}

	// text: String

	public static func <~ <Signal: SignalProtocol>(
		target: UITextField,
		source: Signal
	) -> Disposable? where Signal.Value == String, Signal.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UITextField,
		source: Producer
	) -> Disposable where Producer.Value == String, Producer.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UITextField,
		source: Property
	) -> Disposable where Property.Value == String {
		return target.reactive.text <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UITextField,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == String {
		return target.reactive.text <~ source
	}
}
extension UISegmentedControl {

	// selectedSegmentIndex: Int

	public static func <~ <Signal: SignalProtocol>(
		target: UISegmentedControl,
		source: Signal
	) -> Disposable? where Signal.Value == Int, Signal.Error == NoError {
		return target.reactive.selectedSegmentIndex <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UISegmentedControl,
		source: Producer
	) -> Disposable where Producer.Value == Int, Producer.Error == NoError {
		return target.reactive.selectedSegmentIndex <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UISegmentedControl,
		source: Property
	) -> Disposable where Property.Value == Int {
		return target.reactive.selectedSegmentIndex <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UISegmentedControl,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == Int {
		return target.reactive.selectedSegmentIndex <~ source
	}
}
extension UIImageView {

	// image: UIImage

	public static func <~ <Signal: SignalProtocol>(
		target: UIImageView,
		source: Signal
	) -> Disposable? where Signal.Value == UIImage, Signal.Error == NoError {
		return target.reactive.image <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UIImageView,
		source: Producer
	) -> Disposable where Producer.Value == UIImage, Producer.Error == NoError {
		return target.reactive.image <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UIImageView,
		source: Property
	) -> Disposable where Property.Value == UIImage {
		return target.reactive.image <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UIImageView,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == UIImage {
		return target.reactive.image <~ source
	}
}
extension UIProgressView {

	// progress: Float

	public static func <~ <Signal: SignalProtocol>(
		target: UIProgressView,
		source: Signal
	) -> Disposable? where Signal.Value == Float, Signal.Error == NoError {
		return target.reactive.progress <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UIProgressView,
		source: Producer
	) -> Disposable where Producer.Value == Float, Producer.Error == NoError {
		return target.reactive.progress <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UIProgressView,
		source: Property
	) -> Disposable where Property.Value == Float {
		return target.reactive.progress <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UIProgressView,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == Float {
		return target.reactive.progress <~ source
	}
}
extension UILabel {

	// text: String?

	public static func <~ <Signal: SignalProtocol>(
		target: UILabel,
		source: Signal
	) -> Disposable? where Signal.Value == String?, Signal.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UILabel,
		source: Producer
	) -> Disposable where Producer.Value == String?, Producer.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UILabel,
		source: Property
	) -> Disposable where Property.Value == String? {
		return target.reactive.text <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UILabel,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == String? {
		return target.reactive.text <~ source
	}

	// text: String

	public static func <~ <Signal: SignalProtocol>(
		target: UILabel,
		source: Signal
	) -> Disposable? where Signal.Value == String, Signal.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UILabel,
		source: Producer
	) -> Disposable where Producer.Value == String, Producer.Error == NoError {
		return target.reactive.text <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UILabel,
		source: Property
	) -> Disposable where Property.Value == String {
		return target.reactive.text <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UILabel,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == String {
		return target.reactive.text <~ source
	}

	// attributedText: NSAttributedString?

	public static func <~ <Signal: SignalProtocol>(
		target: UILabel,
		source: Signal
	) -> Disposable? where Signal.Value == NSAttributedString?, Signal.Error == NoError {
		return target.reactive.attributedText <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UILabel,
		source: Producer
	) -> Disposable where Producer.Value == NSAttributedString?, Producer.Error == NoError {
		return target.reactive.attributedText <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UILabel,
		source: Property
	) -> Disposable where Property.Value == NSAttributedString? {
		return target.reactive.attributedText <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UILabel,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == NSAttributedString? {
		return target.reactive.attributedText <~ source
	}

	// attributedText: NSAttributedString

	public static func <~ <Signal: SignalProtocol>(
		target: UILabel,
		source: Signal
	) -> Disposable? where Signal.Value == NSAttributedString, Signal.Error == NoError {
		return target.reactive.attributedText <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: UILabel,
		source: Producer
	) -> Disposable where Producer.Value == NSAttributedString, Producer.Error == NoError {
		return target.reactive.attributedText <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: UILabel,
		source: Property
	) -> Disposable where Property.Value == NSAttributedString {
		return target.reactive.attributedText <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: UILabel,
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == NSAttributedString {
		return target.reactive.attributedText <~ source
	}
}


extension UIDatePicker: DefaultSignalProvider {
	public var defaultSignal: Signal<Date, NoError> {
		return reactive.dates
	}
}
extension UITextField: DefaultSignalProvider {
	public var defaultSignal: Signal<String?, NoError> {
		return reactive.textValues
	}
}
extension UISwitch: DefaultSignalProvider {
	public var defaultSignal: Signal<Bool, NoError> {
		return reactive.isOnValues
	}
}
extension UITextView: DefaultSignalProvider {
	public var defaultSignal: Signal<String, NoError> {
		return reactive.textValues
	}
}
extension UISegmentedControl: DefaultSignalProvider {
	public var defaultSignal: Signal<Int, NoError> {
		return reactive.selectedSegmentIndexes
	}
}

%{
import os
import sys

try:
	framework
except NameError:
	sys.exit("`-Dframework` is not specified. Expected `AppKit`, `UIKit` or `WatchKit`.")

try:
	target
except NameError:
	sys.exit("`-Dtarget` is not specified. Expected `macOS`, `iOS`, `tvOS` or `watchOS`.")

### Load the configuration file for the framework.

config_name = "BindingTargetSubstituting.gyb.py"
config_path = os.path.dirname(os.path.realpath(__file__)) + "/" + framework + "/" + config_name

shared_config_name = "BindingTargetSubstituting.gyb.py"
shared_config_path = os.path.dirname(os.path.realpath(__file__)) + "/Shared/" + config_name

if not os.path.exists(config_path):
	sys.exit(config_path + " was not found.")

if not os.path.exists(shared_config_path):
	sys.exit(shared_config_path + " was not found.")

imports = []
exported_targets = {}
default_signals = {}

execfile(config_path)
execfile(shared_config_path)
}%
// This is auto-generated by gyb.

import Foundation
import ReactiveSwift
import enum Result.NoError
% for import_expr in imports:
import ${import_expr}
% end

% for exporting_class_name, properties in exported_targets.items():
extension ${exporting_class_name} {
	% for (type, target_name) in properties:

	// ${target_name}: ${type}

	public static func <~ <Signal: SignalProtocol>(
		target: ${exporting_class_name},
		source: Signal
	) -> Disposable? where Signal.Value == ${type}, Signal.Error == NoError {
		return target.reactive.${target_name} <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: ${exporting_class_name},
		source: Producer
	) -> Disposable where Producer.Value == ${type}, Producer.Error == NoError {
		return target.reactive.${target_name} <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: ${exporting_class_name},
		source: Property
	) -> Disposable where Property.Value == ${type} {
		return target.reactive.${target_name} <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: ${exporting_class_name},
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == ${type} {
		return target.reactive.${target_name} <~ source
	}
	% if type[-1:] == "?":
	%{ wrapped_type = type[:-1] }%

	// ${target_name}: ${wrapped_type}

	public static func <~ <Signal: SignalProtocol>(
		target: ${exporting_class_name},
		source: Signal
	) -> Disposable? where Signal.Value == ${wrapped_type}, Signal.Error == NoError {
		return target.reactive.${target_name} <~ source
	}

	public static func <~ <Producer: SignalProducerProtocol>(
		target: ${exporting_class_name},
		source: Producer
	) -> Disposable where Producer.Value == ${wrapped_type}, Producer.Error == NoError {
		return target.reactive.${target_name} <~ source
	}

	public static func <~ <Property: PropertyProtocol>(
		target: ${exporting_class_name},
		source: Property
	) -> Disposable where Property.Value == ${wrapped_type} {
		return target.reactive.${target_name} <~ source
	}

	public static func <~ <Provider: DefaultSignalProvider>(
		target: ${exporting_class_name},
		source: Provider
	) -> Disposable? where Provider.DefaultSignalValue == ${wrapped_type} {
		return target.reactive.${target_name} <~ source
	}
	% end
	% end
}
% end


% for exporting_class_name, (type, name) in default_signals.items():
extension ${exporting_class_name}: DefaultSignalProvider {
	public var defaultSignal: Signal<${type}, NoError> {
		return reactive.${name}
	}
}
% end
